|.arch x64
|.section code

// 调用者保存寄存器：RAX, RDI, RSI, RDX, RCX, R8-R11。
// 被调用者保存寄存器：RBP, RBX, R12-R15。
|.type VM,		 VM,	r15	        // VM
|.type TOP,      Value, r14         // VM->stackTop 
|.type CF,		 CallFrame, r13	    // VM->frames[VM->frameCount-1]
|.type JS,       JitState, r12      // VM->J
|.type CLOSURE,	 ObjClosure, rbx	// CallFrame->closure

|.define TMP1,   r10
|.define TMP2,   r11

|.type VALUE,	    Value
|.type CFRAME,		CallFrame
|.type OBJ,	        Obj
|.type OFUNCTION,	ObjFunction
|.type ONATIVE,		ObjNative
|.type OSTRING,	    ObjString
|.type OUPVALUE,	ObjUpvalue
|.type OCLOSURE,	ObjClosure
|.type OCLASS,		ObjClass
|.type OINSTANCE,	ObjInstance
|.type OMETHOD,		ObjBoundMethod
|.type TABLE,		Table
|.type ENTRY,		Entry

|.define LOX_OBJ_BOUND_METHOD,  0
|.define LOX_OBJ_CLASS,		    1
|.define LOX_OBJ_CLOSURE,       2
|.define LOX_OBJ_FUNCTION,		3
|.define LOX_OBJ_INSTANCE,		4
|.define LOX_OBJ_NATIVE,		5
|.define LOX_OBJ_STRING,		6
|.define LOX_OBJ_UPVALUE,		7

|.define CARG1,		rdi		// x64/POSIX C call arguments.
|.define CARG2,		rsi
|.define CARG3,		rdx
|.define CARG4,		rcx
|.define CARG5,		r8
|.define CARG6,		r9

|.macro call64, func
|  mov64 rax, (ptrdiff_t)func
|  call rax
|.endmacro

|.macro subfc1
|  mov64 rax, (ptrdiff_t)(&vm.frameCount)
|  sub dword [rax], 1
|.endmacro


|.actionlist actionList
|.globals jitGlobal_

const char loxJIT_arch[] = "x64";

static void debugger() {
    static int num = 0;
    num++;
    printf("debugger:%d\n", num);
}

// 要保证栈对齐 16字节 即除rbp外，push reg要成对出现，否则会造成Segmentation fault (core dumped)
static void preCall(Dst_DECL) {
    |.code
    |->main:
    | push rbp
    | mov  rbp, rsp
    | push rbx
    | push rbx
    | push r12
    | push r13
    | push r14
    | push r15
    | mov JS, CARG1
    | mov64 VM, (ptrdiff_t)&vm
    | mov eax, VM->frameCount
    | sub eax, 1
    | mov TMP1, sizeof(CallFrame)
    | mul TMP1
    | mov TMP2, VM->frames
    | add TMP2, rax
    | mov CF, TMP2
    | mov TOP, VM->stackTop
}

static void jitOpConstant(Dst_DECL, size_t* i) {
    (*i)++;
    uint8_t idx = J->closure->function->chunk.code[*i];
    Value constant = J->closure->function->chunk.constants.values[idx];
    | mov64 CARG1, (ptrdiff_t)constant
    | call64 push
}

static void jitOpNil(Dst_DECL) {
    | mov64 CARG1, (ptrdiff_t)NIL_VAL
    | call64 push
}

static void jitOpTrue() {}

static void jitOpFalse() {}

static void jitOpPop() {}

static void jitOpGetLocal() {}

static void jitOpSetLocal() {}

static void jitOpGetGlobal() {}

static void jitOpDefineGlobal(Dst_DECL, size_t* i) {
    (*i)++;
    uint8_t idx = J->closure->function->chunk.code[*i];
    ObjString *name = AS_STRING(J->closure->function->chunk.constants.values[idx]);
    | mov CARG1, 0
    | call64 peek
    | mov64 CARG1, (ptrdiff_t)&vm.globals
    | mov64 CARG2, (ptrdiff_t)name
    | mov CARG3, rax
    | call64 tableSet
    | call64 pop
}

static void jitOpSetGlobal(Dst_DECL, size_t* i) {
    ObjString *name = AS_STRING(J->closure->function->chunk.constants.values[*i]);
    (*i)++;
    | mov CARG1, 0
    | call64 peek
    | mov CARG1, VM->globals
    | mov64 CARG2, (ptrdiff_t)name
    | mov CARG3, rax
    | call64 tableSet
    | call64 pop
}

static void jitOpGetUpvalue() {}

static void jitOpSetUpvalue() {}

static void jitOpGetProperty() {}

static void jitOpSetProperty() {}

static void jitOpGetSuper() {}

static void jitOpEqual() {}

static void jitOpGreater() {}

static void jitOpLess() {}

static void jitOpAdd() {}

static void jitOpSubtract() {}

static void jitOpMultiply() {}

static void jitOpDivide() {}

static void jitOpNot() {}

static void jitOpNegate() {}

static void jitOpPrint(Dst_DECL) {
    | call64 pop
    | mov CARG1, rax
    | call64 printValue
    | mov CARG1, '\n'
    | call64 putchar
}

static void jitOpJump() {}

static void jitOpJumpIfFalse() {}

static void jitOpLoop() {}

static void jitOpCall() {}

static void jitOpInvoke() {}

static void jitOpSuperInvoke() {}

static void jitOpClosure() {}

static void jitOpCloseUpvalue() {}

static void jitOpReutrn(Dst_DECL) {
    | call64 pop
    | mov TMP1, rax
    | mov CARG1, CF->slots
    | call64 closeUpvalues
    | subfc1
    | mov eax, VM->frameCount
    | test eax, eax
    | jz >1
    | jmp >2
    |1:
    | call64 pop
    | mov rax, 0
    | jmp >3
    |2:
    | mov TMP2, CF->slots
    | mov VM->stackTop, TMP2
    | mov CARG1, TMP1
    | call64 push
    | mov TMP2, VM->frames
    | mov eax, VM->frameCount
    | sub eax, 1
    | mov TMP1, sizeof(CallFrame)
    | mul TMP1
    | add TMP2, rax
    | mov CF, TMP2
    |3:
    | pop r15
    | pop r14
    | pop r13
    | pop r12
    | pop rbx
    | pop rbx
    | pop rbp
    | ret 
}

static void jitOpClass() {}

static void jitOpInherit() {}

static void jitOpMethod() {}
